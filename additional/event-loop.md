З’являються задачі для виконання – рушій виконує їх – потім очікує нових завдань (майже не навантажуючи процесор в режимі очікування).

Може трапитись так, що завдання приходить тоді, коли рушій вже зайнятий, тоді це завдання стає в чергу.

Чергу з таких завдань називають “чергою макрозавдань” (“macrotask queue”, термін v8):

Задачі з черги виконуються за правилом “перший прийшов – перший пішов”. Коли рушій браузера закінчить виконання script, він обробить подію mousemove, потім виконає обробник setTimeout тощо.

Ще декілька деталей:

Рендеринг ніколи не відбувається поки рушій виконує завдання. Не має значення наскільки довго виконується завдання. Зміни в DOM будуть відмальовані лише після завершення завдання.

Якщо виконання завдання займає надто багато часу, браузер не зможе виконувати інші завдання, наприклад, обробляти користувацькі події. Тож після недовгого часу “зависання” з’явиться оповіщення “Сторінка не відповідає” і пропозиція вбити процес виконання завдання разом з цілою сторінкою. Таке трапляється коли код містить багато складних обрахунків або виникає програмна помилка, що створює нескінченний цикл.

Застосування:

###### Приклад 1: розбиття ресурсозатратних завдань

Наприклад, функція яка рахує від 1 до 1000000000. Якщо ви запустите код нижче, рушій “зависне” на деякий час, жодна з інших подій не спрацює поки цей код не завершиться. Браузер навіть може показати повідомлення “скрипт виконується надто довго”.


<script>

let i = 0;

let start = Date.now();

function count() {

  // робимо важку роботу
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Виконано за " + (Date.now() - start) + 'мс');
}

count();


Ми можемо уникнути проблем шляхом розбивання великого завдання на шматочки.

let i = 0;

let start = Date.now();

function count() {

  // робимо частину важкої роботи (*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count); // плануємо новий виклик (**)
  }

}

count();
</script>

Простий виклик count робить частину роботи (*), і потім планує свій же виклик (**), якщо це необхідно:

Перше виконання обчислює: i=1...1000000.
Друге виконання обчислює: i=1000001..2000000.
…і так далі.

Тепер, якщо з’являється нове стороннє завдання (таке як подія onclick) поки рушій виконує частину 1, воно стає в чергу і виконується після закінчення частини 1, перед наступною частиною. 

Примітна річ, що обидва варіанти – з розбиттям і без розбиття роботи з setTimeout – майже не відрізняються за швидкістю.
Щоб зменшити цю різницю ще сильніше, давайте перенесемо планування виклику в початок count()
<script>

let i = 0;

let start = Date.now();

function count() {

  // переносимо планування виклику в початок
  if (i < 1e9 - 1e6) {
    setTimeout(count); // плануємо новий виклик
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Виконано за " + (Date.now() - start) + 'мс');
  }

}
</script>

count();

Тепер виконання займає значно менше часу. в браузера є мінімальна затримка в 4мс при багатьох вкладених викликах setTimeout. Навіть якщо ми встановимо 0, насправді це буде 4ms (або трохи більше). Тож чим раніше ми заплануємо виклик – тим швидше виконається код.


##### Приклад 2: індикація прогресу

Але можливо ми хочемо показати щось під час виконання завдання, наприклад індикатор прогресу.

Якщо ми розділимо велике завдання на частини використовуючи setTimeout, тоді зміни будуть відмальовані в проміжках між частинами.

Це вже виглядає краще:

<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // зробити шматочок важкої роботи (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }

  }

  count();
</script>

###### Приклад 3: виконання чогось після події

В обробнику подій ми можемо вирішити відкласти певні дії поки подія не вспливе і не буде оброблена на всіх рівнях. Ми можемо зробити це огорнувши код в setTimeout з нульовою затримкою.
<script>

menu.onclick = function() {
  // ...

  // створюємо кастомну подію з даними клікнутого пункту меню
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
  });

  // асинхронно згенерувати кастомну подію
  setTimeout(() => menu.dispatchEvent(customEvent));
};
</script>

#### Макрозавдання (Macrotasks) та Мікрозавдання (Microtasks)

Мікрозавдання приходять лише з нашого коду. Їх зазвичай створюють проміси: виконання обробника .then/catch/finally стає мікрозавданням. Мікрозавдання також використовуються “під капотом” await, так як це форма обробки проміса.

Також існує спеціальна функція queueMicrotask(func), яка ставить func в чергу мікрозавдань.

Одразу після кожного макрозавдання, рушій виконує всі завдання з черги мікрозавдань перед тим як виконати якесь макрозавдання чи рендеринг чи виконати щось іще.
<script>

setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");

</script>

Якщо ми хочемо виконати функцію асинхронно (після поточного коду), але до відображення змін чи обробки нових подій, ми можемо запланувати її за допомогою queueMicrotask.

<div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // зробити частину великого завдання (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      queueMicrotask(count);
    }

  }

  count();
</script>


Підсумки: 
Щоб додати в чергу нове макрозавдання:

Використайте setTimeout(f) з нульовою затримкою. 
Цей спосіб можна використати для розбиття великого ресурсозатратного завдання на частини, щоб браузер мав змогу реагувати на користувацькі події і показувати індикатор прогресу між ними. Також це використовується в обробниках подій, щоб відкласти дію до моменту повної обробки події (вспливання завершене).

Щоб запланувати нове мікрозавдання

Використайте queueMicrotask(f).
Також обробники промісів виконуються в черзі мікрозавдань.

Для довгих важких обчислень, які не повинні блокувати цикл подій, ми можемо використати Web Workers.Web Workers не мають доступу до DOM, тож вони корисні переважно для обчислень. Вони можуть використовувати декілька ядер процесора одночасно.
https://html.spec.whatwg.org/multipage/workers.html

<script>

console.log(1);

setTimeout(() => console.log(2));

Promise.resolve().then(() => console.log(3));

Promise.resolve().then(() => setTimeout(() => console.log(4)));

Promise.resolve().then(() => console.log(5));

setTimeout(() => console.log(6));

console.log(7);

</script>

- Числа 1 і 7 з’являються відразу, тому що прості виклики console.log не використовують жодних черг.
- Потім, після завершення основного потоку коду, запускається черга мікрозадач.
- Він містить команди: console.log(3); setTimeout(...4); console.log(5).
- З’являються числа 3 і 5, а setTimeout(() => console.log(4)) додає виклик console.log(4) в кінець черги макрозадач.
- Черга макрозадач тепер така: console.log(2); console.log(6); console.log(4).
- Після того як черга мікрозадач стає порожньою, виконується черга макрозадач. І він виводить 2, 6, 4.
Нарешті, маємо у консолі: 1 7 3 5 2 6 4.