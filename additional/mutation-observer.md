Спершу ми створюємо спостерігача із функцією зворотного виклику:

let observer = new MutationObserver(callback);

А потім прикріплюємо його до вузла DOM:

observer.observe(node, config);

config – це об’єкт із булевими опціями, які вказують “на якого роду зміни слід реагувати”:

- childList – зміни в безпосередніх нащадках вузла node,
- subtree – у всіх нащадках вузла node,
- attributes – атрибути вузла node,
- attributeFilter – масив назв атрибутів, щоб спостерігати лише за певними з них.
- characterData – чи спостерігати за змінами в node.data (текстовий вміст),

Далі після будь-яких змін виконується callback: зміни передаються першим аргументом у вигляді списку об’єктів типу MutationRecord, а другим аргументом передається сам спостерігач.

Об’єкти MutationRecord містять такі властивості:

- type – тип мутації, одне з:
    - "attributes": змінився атрибут
    - "characterData": змінилися дані, використовуються для текстових вузлів,
    - "childList": додані/прибрані дочірні елементи,
- target – де саме відбулася зміна: для "attributes" це елемент, або текстовий вузол у випадку "characterData", або елемент для мутації типу "childList",
- addedNodes/removedNodes – вузли, які було додано/прибрано,
- previousSibling/nextSibling – відповідно попередній та наступний елемент відносно доданих/прибраних вузлів,
- attributeName/attributeNamespace – ім’я/простір імен (для XML) зміненого атрибута,
- oldValue – попереднє значення, лише для змін в атрибуті або тексті, за умови, що встановлено відповідний параметр attributeOldValue/characterDataOldValue.



Наприклад, ось елемент <div> із атрибутом contentEditable. Цей атрибут дає нам змогу переміщувати фокус на нього і редагувати.

<div contentEditable id="elem">Натисни і <b>редагуй</b>, будь ласка</div>

<script>
let observer = new MutationObserver(mutationRecords => {
  console.log(mutationRecords); // console.log(зміни)
});

// спостерігати за всім окрім атрибутів
observer.observe(elem, {
  childList: true, // спостерігати за безпосередніми нащадками
  subtree: true, // і також за глибшими нащадками
  characterDataOldValue: true // передавати старі дані до функції зворотного виклику
});
</script>


console.log покаже:
 mutationRecords = [{
  type: "characterData",
  oldValue: "edit",
  target: <text node>,
  // інші властивості порожні
}];

Існує метод для зупинки спостереження за вузлом:

observer.disconnect() – зупиняє спостереження.
Коли ми припиняємо спостереження, може трапитися ситуація, що деякі зміни ще не були оброблені спостерігачем. В таких випадках, ми вживаємо

observer.takeRecords() – отримує перелік необроблених записів мутацій – тих, що трапилися, проте функція зворотного виклику їх ще не опрацювала.
Ці методи можна застосовувати разом, як це показано далі:

// отримання переліку необроблених мутацій
// повинно викликатись перед роз'єднанням,
// якщо для вас важливі потенційно необроблені недавні мутації
let mutationRecords = observer.takeRecords();

// зупинка відстежування змін
observer.disconnect();
...