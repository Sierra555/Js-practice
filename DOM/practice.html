<!DOCTYPE html>
<html>
<body>
<h2>properties</h2> 

  <div data-widget-name="menu">Виберіть жанр</div>

  <script>
   const widget = document.querySelector('[data-widget-name]');
   console.log(widget.dataset.dataWidgetName);
  </script>

<h4> Зробіть зовнішні посилання помаранчевими
В його href є ://
Але не починається з http://internal.com.
</h4>

<a name="list">список</a>
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

<script>
  let linkHrefs = document.querySelectorAll('a').getAttribute('href');
  linkHrefs.forEach(href => {
    if (href.includes('://') && !href.startsWith('http://internal.com')) {
    link.style.color = 'orange';
  }
  });
  
</script>

<!-- інший спосіб -->
<!-- let selector = 'a[href*="://"]:not([href^="http://internal.com"])';
let links = document.querySelectorAll(selector);

links.forEach(link => link.style.color = 'orange'); -->

<h2>document-modifying </h2>

<h4> Створіть функцію clear(elem) яка видаляє все з елементу. </h4>

<ol id="elem">
  <li>Привіт</li>
  <li>Світ</li>
</ol>

<script>
  function clear(elem) { 
    while (elem.firstChild) {
    elem.firstChild.remove();
  }
}
  //   const listItems = document.querySelector(`#${elem}`).querySelectorAll('li');
  //   listItems.forEach(item => {
  //     item.remove();
  //   });
    

  // elem.innerHTML = '';

  clear(elem); // очищує список
</script>

<h4>Напишіть код, щоб вставити <xmp><li>2</li><li>3</li></xmp> між двома <xmp><li></xmp> тут:</h4>

<ul id="ul">
  <li id="one">1</li>
  <li id="two">4</li>
</ul> 
<script>

document.getElementById('one').insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');
</script>


<h4> Напишіть інтерфейс для створення списку на основі того, що введе користувач.

Для кожного пункта списку:

Запитайте текст пункту у користувача за допомогою prompt.
Створіть li з цим текстом та додайте його до ul.
Продовжуйте поки користувач не припинить вводити дані (натисне Esc або введе пустий рядок).
Всі елементи повинні створюватися динамічно.

Якщо користувач вводить HTML-теги, вони мають розглядатися як текст. </h4>

<script>
  const list = document.createElement('ul');
  document.body.append(list);
  
  while (true) {
    const data = prompt();
    
    if (!data) {
      break;
    }
    else {
      const listItem = document.createElement('li');
    list.insertAdjacentElement('beforeend',listItem);
    listItem.textContent = data;
    }
  }
</script>
<h4> Напишіть функцію createTree яка створює вкладений ul/li список з вкладеного об’єкта.</h4>

<script>
  let data = {
  Риба: {
    форель: {},
    лосось: {}
  },

  Дерево: {
    Величезні: {
      секвойя: {},
      дуб: {}
    },
    Квітучі: {
      яблуня: {},
      магнолія: {}
    }
  }
};

const ul = document.createElement('ul');
document.body.append(ul);

// ul.innerHTML = createTreeText(data);
//   function createTreeText(obj) { 
//       let li = '';
//       let ul;
//       for (let key in obj) {
//         li += '<li>' + key + createTreeText(obj[key]) + '</li>';
//       }
//       if (li) {
//         ul = '<ul>' + li + '</ul>'
//       }
//       return ul || '';
//     }


function createTreeDom(data) {
  if (!Object.keys(data).length) return;
  let ul = document.createElement('ul');

  for (let key in data) {
    let listItem = document.createElement('li');
    listItem.textContent = key;

    let subList = createTree(data[key]);
    if(subList) {
      listItem.append(subList);
    }

    ul.append(listItem);
  }
  return ul;
}

function createTree(container, obj) {
    container.append(createTreeDom(obj));
}
createTree(ul,data);
</script>


<h2>ClassList</h2>

<h4>Напишіть функцію showNotification(options), яка створює сповіщення div class="notification" з переданим вмістом. Сповіщення повинно автоматично зникати через 1.5 секунди.</h4>
<script>

function showNotification({top = 0, right = 0, className, html}) {
  const notification = document.createElement('div');
  document.body.append(notification);
  notification.style.display='block';
  notification.style.position='absolute';
  notification.style.top = `${top}px`;
  notification.style.right = `${right}px`;
  notification.classList.add(className);
  notification.textContent= html;

    setTimeout(() =>  {notification.style.display='none';}, 1500)
}

  showNotification({
  top: 10, 
  right: 10, 
  html: "Hello!",
  className: "welcome" 
})
</script>

<h2>Scroll</h2>

<h4>Що прокрутиться від низу?</h4>
<script>
let scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;
</script>
<h4>Яка ширина смуги прокрутки?</h4>
<script>
  let scrollBarWidth = elem.offsetWidth - elem.clientLeft - elem.clientWidth;
</script>

<h4>Помістіть м'яч у центр поля</h4>
<script>
  ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';
  ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';
</script>

<h4>Яка різниця між getComputedStyle(elem).width і elem.clientWidth?</h4>
<ul>
  <li>getComputedStyle(elem).width вертає значення з px, а elem.clientWidth - число без одиниці вимірювання</li>
  <li>CSS це внутрішня область вмісту без відступів, а elem.clientWidth враховує відступи</li>
  <li>CSS ширина може мати auto, що є безкорисливим для розрахунків у JS</li>
  <li>деякі браузери віднімають ширину скролі, а деякі ні, а elem.clientWidth ніколи не враховує скрол</li>
</ul>
</body>
</html>

<h2>Coordinates</h2>
<div id="coords">(координати кліку з’являться тут)</div>


<div id="field">
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
</div>


<div class="triangle-right" style="left:-20px;top:-176px">1</div>
<div class="triangle-right" style="left:-10px;top:-178px">3</div>
<div class="triangle-right" style="left:190px;top:-40px">4</div>
<div class="triangle-right" style="left:200px;top:-42px">2</div>


<script>

function getCoordinate(elem) {
const box = document.querySelector(elem);
const coords = box.getBoundingClientRect();
const topLeft = {x: coords.left , y: coords.top};
const bottomRight = {x: coords.right , y: coords.bottom};
const topLeftInner = {x: topLeft.x + box.clientLeft, y: topLeft.y + box.clientTop}
const bottomRightInner = {x: box.clientWidth + coords.left + box.clientLeft, y: box.clientHeight + box.clientTop + coords.top };

console.log(topLeft);
console.log(bottomRight);
console.log(topLeftInner);
console.log(bottomRightInner);
}

getCoordinate('#field')
</script>