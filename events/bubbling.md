#### Спливання

Коли подія відбувається на елементі, спочатку запускаються обробники на ньому, потім на його батькові, потім на інших предках і так до самого верху.

Подія focus не спливає.

Найбільш глибоко вкладений елемент, що викликав подію, називається цільовим елементом, та доступний як event.target

event.target – “цільовий” елемент, який ініціював подію, він не змінюється в процесі спливання.
this – “поточний” елемент, той, на якому в даний момент виконується обробник.

В середині form.onclick обробника:

this (=event.currentTarget) це елемент <form>, тому що обробник виконується на ньому.
event.target це власне елемент всередині форми, на якому було зроблено клік.

 #### Припинення спливання

Якщо на елементі є кілька обробників подій для однієї події, то навіть якщо один з них зупиняє спливання, інші все одно виконуються.

Іншими словами, event.stopPropagation() зупиняє подальше рухання вгору, але на поточному елементі виконуються всі інші обробники.

Щоб зупинити спливання та запобігти виконанню обробників на поточному елементі, є метод event.stopImmediatePropagation(). Після його виклику інші обробники не виконуються.

#### Занурення

Це означає, що для кліку на <td> подія спочатку проходить вниз по ланцюжку предків до елемента (фаза занурення), потім досягає цільового елемента і там спрацьовує (фаза цілі), а потім вона піднімається вгору (фаза спливання), викликаючи обробники на своєму шляху.


Щоб перехопити подію на фазі занурення (capturing phase), нам потрібно встановити опцію capture обробника на значення true:

elem.addEventListener(..., { capture: true })

Зверніть увагу, що хоча формально є 3 фази, друга фаза (“фаза цілі”: подія досягла елемента) не обробляється окремо: обробники як на фазі занурення, так і на фазі спливання викликаються на цій фазі.

Існує властивість event.eventPhase, яка показує нам номер фази, на якій було зловлено подію. Але це рідко використовується, оскільки ми зазвичай знаємо це в обробнику.

##### Якщо ми встановили addEventListener(..., true), то ми повинні вказати ту ж фазу в removeEventListener(..., true), щоб правильно видалити обробник.


Метод event.stopPropagation() під час занурення також перешкоджає спливанню події

Тоді не тільки зупиняється подальше занурення, але і спливання події.