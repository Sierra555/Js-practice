
Cенсорні події: touchstart, touchend, touchmove, які мають властивості, специфічні для дотику (тут ми не розглядаємо їх детально, тому що події вказівника ще кращі).

#### Типи подій вказівника


Події вказівника	Аналогічні події миші

pointerdown	        mousedown
pointerup	        mouseup
pointermove	        mousemove
pointerover	        mouseover
pointerout	        mouseout
pointerenter	    mouseenter
pointerleave	    mouseleave
pointercancel	    -
gotpointercapture	-
lostpointercapture	-

#### Властивості події вказівника

Події вказівника мають ті самі властивості, що й події миші, такі як clientX/Y, target тощо, а також деякі інші:

pointerId – унікальний ідентифікатор вказівника, що спричиняє подію.

Згенерований браузером. Дозволяє нам працювати з кількома вказівниками, такими як сенсорний екран зі стилусом і мультитач (приклади будуть далі).

pointerType – тип вказівного пристрою. Має бути рядком, одним із таких: “mouse”, “pen” або “touch”.

Ми можемо використовувати цю властивість, щоб по-різному реагувати на різні типи вказівників.

isPrimary – true для основного вказівника (перший палець у мультитач).

Додатаково: Деякі вказівні пристрої вимірюють площу контакту та тиск, напр. для пальця на сенсорному екрані є додаткові властивості для цього:

width – ширина області, де вказівник (наприклад, палець) торкається пристрою. Якщо не підтримується, напр. для миші це завжди 1.
height – висота області, де вказівник торкається пристрою. Там, де не підтримується, завжди 1.
pressure – тиск вказівника в діапазоні від 0 до 1. Для пристроїв, які не підтримують тиск, має бути 0,5 (натиснутий) або 0.
tangentialPressure – нормалізований тангенційний тиск.
tiltX, tiltY, twist – специфічні властивості пера, які описують, як воно розташовується відносно поверхні.

#### Мультитач

Ось що відбувається, коли користувач торкається сенсорного екрана в одному місці, а потім кладе інший палець в інше місце:

При першому дотику пальцем:

pointerdown з isPrimary=true та певним pointerId.

Для другого пальця та інших пальців (якщо перший досі торкається):

pointerdown з isPrimary=false та іншим pointerId для кожного пальця.

Якщо ми використовуємо 5 пальців, щоб одночасно торкнутися екрана, у нас буде 5 подій pointerdown, кожна зі своїми відповідними координатами та іншим pointerId.

Коли користувач рухає, а потім прибирає палець, ми отримуємо події pointermove та pointerup з тим же pointerId, що й у pointerdown.

#### Подія: pointercancel

Подія pointercancel спрацьовує, коли відбувається постійна взаємодія вказівника, а потім відбувається щось, що спричиняє її скасування.

Такими причинами є:

Фізичне вимкнення обладнання вказівного пристрою.
Зміна орієнтації пристрою (планшет повернуто).


#### Запобігання типовій дії браузера, щоб уникнути pointercancel.

Нам потрібно зробити дві речі:

Запобігти нативному drag’n’drop:

- Ми можемо зробити це, встановивши ball.ondragstart = () => false, як описано в статті Drag'n'Drop з подіями миші.
Це добре працює для подій миші.

- Для сенсорних пристроїв існують інші дії браузера, пов’язані з дотиком (крім перетягування). Щоб уникнути проблем і з ними:
Запобігти їм, встановивши #ball { touch-action: none } у CSS
Тоді наш код почне працювати на сенсорних пристроях.

#### Захоплення вказівника

Ми можемо викликати thumb.setPointerCapture(event.pointerId) в обробнику pointerdown,
Тоді майбутні події вказівника до pointerup/cancel будуть перенацілені на thumb.
Коли відбувається pointerup (перетягування завершено), прив’язка видаляється автоматично, нам не потрібно перейматись за це.

thumb.onpointerdown = function(event) {
  // перенацілити всі події вказівника на повзунок (до події pointerup)
  thumb.setPointerCapture(event.pointerId);

  // почати відстеження переміщень вказівника
  thumb.onpointermove = function(event) {
    // переміщення повзунка: всі події перенаправлені на цей обробник
    let newLeft = event.clientX - slider.getBoundingClientRect().left;
    thumb.style.left = newLeft + 'px';
  };

  // завершити відстеження рухів вказівника при pointerup
  thumb.onpointerup = function(event) {
    thumb.onpointermove = null;
    thumb.onpointerup = null;
    // ...також обробити "drag end", якщо потрібно
  };
};

// примітка: не потрібно викликати thumb.releasePointerCapture,
// це відбувається при pointerup автоматично


Зрештою, захоплення вказівника дає нам дві переваги:

Код стає чистішим, оскільки нам більше не потрібно додавати/видаляти обробники всього document. Прив’язка прибирається автоматично…
Якщо в документі є інші обробники подій вказівника, вони не будуть випадково ініційовані вказівником, коли користувач перетягує повзунок.

#### Події захоплення вказівника

Існують дві події, пов’язані із захопленням вказівника:

gotpointercapture спрацьовує, коли елемент використовує setPointerCapture для включення захоплення.
lostpointercapture запускається, коли відбувається звільнення від захоплення: або явно за допомогою виклику releasePointerCapture, або автоматично під час pointerup/pointercancel.